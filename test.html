<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Real-time Navigation Tracking with Start Button</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body, html {
            margin: 0; padding: 0; height: 100%; background: #000; color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #map {
            position: absolute; top: 0; bottom: 0; width: 100%;
        }
        .overlay {
            position: absolute; top: 0; left: 0; right: 0; background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 50%, transparent 100%);
            padding: 20px; z-index: 1000; display: flex; justify-content: space-between; align-items: center;
        }
        .direction-info {
            flex: 1;
        }
        .distance {
            font-size: 32px; font-weight: bold; margin-bottom: 5px;
        }
        .street-name {
            font-size: 18px; color: #ccc; margin-bottom: 10px;
        }
        .incident-warning {
            background: rgba(255,165,0,0.2); border: 1px solid orange; border-radius: 8px; padding: 8px 12px; font-size: 14px; color: orange; display: none;
            margin-bottom: 10px;
        }
        .speed-limit {
            background: white; color: black; border-radius: 8px; padding: 12px; text-align: center; min-width: 60px;
        }
        .speed-number {
            font-size: 24px; font-weight: bold; line-height: 1;
        }
        .speed-unit {
            font-size: 12px; font-weight: normal;
        }
        .direction-arrow {
            width: 40px; height: 40px; background: #007bff; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: 10px; font-size: 24px;
            user-select: none;
        }
        .bottom-panel {
            position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.9); padding: 20px; z-index: 1000;
        }
        .route-summary {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;
        }
        .destination {
            font-size: 18px; font-weight: 600;
        }
        .route-stats {
            display: flex; gap: 20px; align-items: center;
        }
        .stat {
            text-align: center;
        }
        .stat-value {
            font-size: 16px; font-weight: bold;
        }
        .stat-label {
            font-size: 12px; color: #ccc;
        }
        .progress-bar {
            height: 6px; background: #333; border-radius: 3px; overflow: hidden;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #ff6b35 0%, #f7931e  50%, #00d4ff 100%);
            border-radius: 3px; transition: width 0.3s ease;
        }
        .controls {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%); z-index: 1000;
        }
        .control-btn {
            display: block; width: 50px; height: 50px; background: rgba(0,0,0,0.7); border: none; border-radius: 8px; color: white; font-size: 20px; margin-bottom: 10px; cursor: pointer; transition: background 0.2s;
        }
        .control-btn:hover {
            background: rgba(0,0,0,0.9);
        }
        .current-location-btn {
            position: absolute; right: 20px; bottom: 140px; width: 50px; height: 50px; background: rgba(0,0,0,0.7); border: none; border-radius: 50%; color: white; font-size: 20px; cursor: pointer; z-index: 1000;
        }
        .search-panel {
            position: absolute; top: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.8); border-radius: 12px; padding: 15px; z-index: 1001; display: none;
        }
        .search-input {
            width: 100%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; padding: 12px; color: white; font-size: 16px; margin-bottom: 10px;
        }
        .search-input::placeholder {
            color: #ccc;
        }
        .search-btn {
            background: #007bff; border: none; border-radius: 8px; padding: 12px 20px; color: white; font-size: 16px; cursor: pointer; margin-right: 10px;
        }
        .cancel-btn {
            background: transparent; border: 1px solid #ccc; border-radius: 8px; padding: 12px 20px; color: #ccc; font-size: 16px; cursor: pointer;
        }
        #startNavigationBtn {
            font-size: 18px;
            padding: 12px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            position: absolute;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1100;
            display: none;
        }
        #startNavigationBtn {
    width: 60px;
    height: 60px;
    background: #007bff;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    position: absolute;
    bottom: 130px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1100;
    display: none;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

#startNavigationBtn svg {
    width: 24px;
    height: 24px;
    fill: white;
    transform: rotate(90deg); /* Xoay cho m≈©i t√™n h∆∞·ªõng v·ªÅ ph·∫£i */
}

    </style>
</head>
<body>
    <div id="map"></div>

    <div class="overlay">
        <div class="direction-info">
            <div class="direction-arrow" id="directionArrow">‚Üë</div>
            <div class="distance" id="nextDistance">-- mi</div>
            <div class="street-name" id="nextStreet">--</div>
            <div class="incident-warning" id="incidentWarning">Incident nearby!</div>
        </div>
        <div class="speed-limit">
            <div class="speed-number" id="speedNumber">--</div>
            <div class="speed-unit">mph</div>
        </div>
    </div>

    <div class="bottom-panel">
        <div class="route-summary">
            <div class="destination" id="destination">--</div>
            <div class="route-stats">
                <div class="stat">
                    <div class="stat-value" id="totalDistance">-- mi</div>
                    <div class="stat-label">Distance</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalTime">-- min</div>
                    <div class="stat-label">Time</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="arrivalTime">--:--</div>
                    <div class="stat-label">Arrival</div>
                </div>
            </div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
    </div>

    <button id="startNavigationBtn">B·∫Øt ƒë·∫ßu</button>

    <div class="controls">
        <button class="control-btn" id="searchBtn" onclick="toggleSearch()">üîç</button>
        <button class="control-btn" onclick="zoomIn()">+</button>
        <button class="control-btn" onclick="zoomOut()">‚àí</button>
        <button class="control-btn" onclick="toggleView()">üó∫Ô∏è</button>
    </div>

    <button class="current-location-btn" onclick="goToCurrentLocation()">üìç</button>

    <div class="search-panel" id="searchPanel">
        <input type="text" class="search-input" id="destinationInput" placeholder="Nh·∫≠p ƒëi·ªÉm ƒë·∫øn..." />
        <button class="search-btn" onclick="searchDestination()">T√¨m ƒë∆∞·ªùng</button>
        <button class="cancel-btn" onclick="toggleSearch()">H·ªßy</button>
    </div>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoibmhhdG5ndXllbnF2IiwiYSI6ImNtYjZydDNnZDAwY24ybm9qcTdxcTNocG8ifQ.u7X_0DfN7d52xZ8cGFbWyQ';

        let map, currentLocation = null, destination = null, routeData = null;
        let currentLocationMarker = null, destinationMarker = null;
        let navigationStarted = false;

        const incident = {
            coordinates: null,
            radius: 0.3 // miles
        };

        function initMap() {
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/navigation-night-v1',
                // T·ªça ƒë·ªô trung t√¢m H√† N·ªôi (Long, Lat)
                center: [105.8542, 21.0285],
                zoom: 14,
                pitch: 60,
                bearing: 0
            });

            map.on('load', () => {
                map.addSource('route', {
                    type: 'geojson',
                    data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] } }
                });

                map.addLayer({
                    id: 'route',
                    type: 'line',
                    source: 'route',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: { 'line-color': '#007bff', 'line-width': 6, 'line-opacity': 0.8 }
                });

                getCurrentLocation();
            });
        }

        function getCurrentLocation() {
            if (!navigator.geolocation) {
                alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã.');
                return;
            }

            navigator.geolocation.getCurrentPosition(
                pos => {
                    currentLocation = [pos.coords.longitude, pos.coords.latitude];
                    addOrUpdateCurrentMarker();

                    map.flyTo({ center: currentLocation, zoom: 15 });

                    navigator.geolocation.watchPosition(updateLocation, err => {
                        console.error(err);
                        alert('L·ªói khi theo d√µi v·ªã tr√≠.');
                    }, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });
                },
                err => {
                    alert('Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i. Vui l√≤ng cho ph√©p truy c·∫≠p v·ªã tr√≠.');
                },
                { enableHighAccuracy: true }
            );
        }

        function updateLocation(pos) {
            currentLocation = [pos.coords.longitude, pos.coords.latitude];
            addOrUpdateCurrentMarker();
            if (navigationStarted) {
                updateNavigationInfo();
                updateCamera();
            }
        }

        function addOrUpdateCurrentMarker() {
            if (currentLocationMarker) {
                currentLocationMarker.setLngLat(currentLocation);
            } else {
                currentLocationMarker = new mapboxgl.Marker({ color: '#007bff' })
                    .setLngLat(currentLocation)
                    .addTo(map);
            }
        }

        function addOrUpdateDestinationMarker() {
            if (destinationMarker) {
                destinationMarker.setLngLat(destination);
            } else {
                destinationMarker = new mapboxgl.Marker({ color: '#ff6b35' })
                    .setLngLat(destination)
                    .addTo(map);
            }
        }

        async function searchDestination() {
            const query = document.getElementById('destinationInput').value.trim();
            if (!query) {
                alert('Vui l√≤ng nh·∫≠p ƒëi·ªÉm ƒë·∫øn.');
                return;
            }

            try {
                const geocodeURL = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${mapboxgl.accessToken}&limit=1`;
                const res = await fetch(geocodeURL);
                const data = await res.json();

                if (data.features.length === 0) {
                    alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm.');
                    return;
                }

                destination = data.features[0].center;
                const destinationName = data.features[0].text;

                addOrUpdateDestinationMarker();
                document.getElementById('destination').textContent = destinationName;

                if (routeData) {
                    map.getSource('route').setData({
                        type: 'Feature',
                        geometry: { type: 'LineString', coordinates: [] }
                    });
                    routeData = null;
                }

                navigationStarted = false;
                document.getElementById('startNavigationBtn').style.display = 'inline-block';
                resetNavigationUI();

                toggleSearch();
            } catch (e) {
                alert('L·ªói khi t√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm.');
                console.error(e);
            }
        }

        function resetNavigationUI() {
            document.getElementById('nextDistance').textContent = '-- mi';
            document.getElementById('nextStreet').textContent = '--';
            document.getElementById('directionArrow').textContent = '‚Üë';
            document.getElementById('totalDistance').textContent = '-- mi';
            document.getElementById('totalTime').textContent = '-- min';
            document.getElementById('arrivalTime').textContent = '--:--';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('incidentWarning').style.display = 'none';
            document.getElementById('speedNumber').textContent = '--';
        }

        document.getElementById('startNavigationBtn').addEventListener('click', async () => {
            if (!destination || !currentLocation) {
                alert('Kh√¥ng c√≥ ƒëi·ªÉm ƒë·∫øn ho·∫∑c v·ªã tr√≠ hi·ªán t·∫°i.');
                return;
            }
            navigationStarted = true;
            document.getElementById('startNavigationBtn').style.display = 'none';
            await getRoute();
        });

        async function getRoute() {
            if (!currentLocation || !destination) return;

            // S·ª≠ d·ª•ng profile driving-traffic ƒë·ªÉ c√≥ route ch√≠nh x√°c nh·∫•t
            const directionsURL = `https://api.mapbox.com/directions/v5/mapbox/driving-traffic/${currentLocation[0]},${currentLocation[1]};${destination[0]},${destination[1]}?steps=true&geometries=geojson&overview=full&alternatives=false&access_token=${mapboxgl.accessToken}`;

            try {
                const res = await fetch(directionsURL);
                const data = await res.json();

                if (!data.routes || data.routes.length === 0) {
                    alert('Kh√¥ng th·ªÉ l·∫•y tuy·∫øn ƒë∆∞·ªùng.');
                    return;
                }

                routeData = data.routes[0];

                // Th√™m layer m·ªõi ƒë·ªÉ hi·ªÉn th·ªã ƒë∆∞·ªùng ƒëi
                if (!map.getSource('route')) {
                    map.addSource('route', {
                        type: 'geojson',
                        data: {
                            type: 'Feature',
                            properties: {},
                            geometry: routeData.geometry
                        }
                    });

                    map.addLayer({
                        id: 'route',
                        type: 'line',
                        source: 'route',
                        layout: {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        paint: {
                            'line-color': '#007bff',
                            'line-width': [
                                "interpolate",
                                ["linear"],
                                ["zoom"],
                                12, 3,
                                16, 6
                            ],
                            'line-opacity': 0.8
                        }
                    });
                } else {
                    map.getSource('route').setData({
                        type: 'Feature',
                        properties: {},
                        geometry: routeData.geometry
                    });
                }

                // Fit bounds v·ªõi padding ƒë·ªÉ hi·ªÉn th·ªã to√†n b·ªô route
                const bounds = new mapboxgl.LngLatBounds();
                routeData.geometry.coordinates.forEach(coord => bounds.extend(coord));
                map.fitBounds(bounds, {
                    padding: {top: 100, bottom: 100, left: 50, right: 50},
                    duration: 1000
                });

                updateNavigationInfo();
            } catch (e) {
                console.error('Error fetching route:', e);
                alert('L·ªói khi l·∫•y tuy·∫øn ƒë∆∞·ªùng.');
            }
        }

        // Th√™m h√†m ƒë·ªÉ c·∫≠p nh·∫≠t camera theo h∆∞·ªõng di chuy·ªÉn
        function updateCamera() {
            if (!currentLocation || !routeData || !navigationStarted) return;

            // T√¨m ƒëi·ªÉm ti·∫øp theo tr√™n route
            const coordinates = routeData.geometry.coordinates;
            let minDistance = Infinity;
            let nextPointIndex = 0;

            coordinates.forEach((coord, index) => {
                const distance = distanceInMiles(currentLocation, coord);
                if (distance < minDistance) {
                    minDistance = distance;
                    nextPointIndex = index;
                }
            });

            // L·∫•y ƒëi·ªÉm ti·∫øp theo ƒë·ªÉ t√≠nh bearing
            const nextPoint = coordinates[Math.min(nextPointIndex + 1, coordinates.length - 1)];
            
            // T√≠nh bearing gi·ªØa v·ªã tr√≠ hi·ªán t·∫°i v√† ƒëi·ªÉm ti·∫øp theo
            const bearing = getBearing(
                [currentLocation[1], currentLocation[0]],
                [nextPoint[1], nextPoint[0]]
            );

            // C·∫≠p nh·∫≠t camera
            map.easeTo({
                center: currentLocation,
                bearing: bearing,
                pitch: 60,
                duration: 1000
            });
        }

        // Th√™m h√†m t√≠nh bearing
        function getBearing(start, end) {
            const startLat = start[0] * Math.PI / 180;
            const startLng = start[1] * Math.PI / 180;
            const endLat = end[0] * Math.PI / 180;
            const endLng = end[1] * Math.PI / 180;

            const dLng = endLng - startLng;

            const y = Math.sin(dLng) * Math.cos(endLat);
            const x = Math.cos(startLat) * Math.sin(endLat) -
                    Math.sin(startLat) * Math.cos(endLat) * Math.cos(dLng);

            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            bearing = (bearing + 360) % 360;

            return bearing;
        }

        function distanceInMiles(coord1, coord2) {
            const R = 3958.8;
            const rad = Math.PI / 180;
            const dLat = (coord2[1] - coord1[1]) * rad;
            const dLon = (coord2[0] - coord1[0]) * rad;
            const lat1 = coord1[1] * rad;
            const lat2 = coord2[1] * rad;

            const a = Math.sin(dLat/2) ** 2 +
                      Math.sin(dLon/2) ** 2 * Math.cos(lat1) * Math.cos(lat2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function getNextStepInfo() {
            if (!routeData || !currentLocation) return null;
            const steps = routeData.legs[0].steps;
            if (!steps || steps.length === 0) return null;

            let closestStep = steps[0];
            let minDist = Infinity;

            for (const step of steps) {
                const stepStart = step.maneuver.location;
                const dist = distanceInMiles(currentLocation, stepStart);
                if (dist < minDist) {
                    minDist = dist;
                    closestStep = step;
                }
            }
            return closestStep;
        }

        function updateDirectionArrow(modifier) {
            const arrow = document.getElementById('directionArrow');
            let arrowSymbol = '‚Üë';
            switch(modifier) {
                case 'left': arrowSymbol = '‚Üê'; break;
                case 'right': arrowSymbol = '‚Üí'; break;
                case 'sharp left': arrowSymbol = '‚Üô'; break;
                case 'sharp right': arrowSymbol = '‚Üò'; break;
                case 'slight left': arrowSymbol = '‚Üñ'; break;
                case 'slight right': arrowSymbol = '‚Üó'; break;
                case 'straight': default: arrowSymbol = '‚Üë'; break;
            }
            arrow.textContent = arrowSymbol;
        }

        function updateNavigationInfo() {
            if (!routeData || !currentLocation || !navigationStarted) return;

            const totalDistanceMi = (routeData.distance / 1609.34).toFixed(1);
            const totalTimeMin = Math.round(routeData.duration / 60);

            document.getElementById('totalDistance').textContent = totalDistanceMi + ' mi';
            document.getElementById('totalTime').textContent = totalTimeMin + ' min';

            const now = new Date();
            const arrival = new Date(now.getTime() + routeData.duration * 1000);
            document.getElementById('arrivalTime').textContent = arrival.getHours().toString().padStart(2,'0') + ':' + arrival.getMinutes().toString().padStart(2,'0');

            const nextStep = getNextStepInfo();
            if (nextStep) {
                const distNextStep = (nextStep.distance / 1609.34).toFixed(1);
                document.getElementById('nextDistance').textContent = distNextStep + ' mi';
                document.getElementById('nextStreet').textContent = nextStep.name || 'Unnamed road';
                updateDirectionArrow(nextStep.maneuver.modifier);
            } else {
                document.getElementById('nextDistance').textContent = '-- mi';
                document.getElementById('nextStreet').textContent = '--';
                document.getElementById('directionArrow').textContent = '‚Üë';
            }

            const distTravelled = distanceInMiles(routeData.geometry.coordinates[0], currentLocation);
            const distTotal = totalDistanceMi;
            let percent = (distTravelled / distTotal) * 100;
            percent = Math.min(Math.max(percent, 0), 100);
            document.getElementById('progressFill').style.width = percent + '%';

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(pos => {
                    const speed = pos.coords.speed ? (pos.coords.speed * 2.23694) : 0;
                    document.getElementById('speedNumber').textContent = speed.toFixed(0);
                });
            }

            checkIncident();
        }

        function checkIncident() {
            if (!incident.coordinates || !currentLocation) {
                document.getElementById('incidentWarning').style.display = 'none';
                return;
            }

            const distToIncident = distanceInMiles(currentLocation, incident.coordinates);
            if (distToIncident <= incident.radius) {
                document.getElementById('incidentWarning').style.display = 'block';
                document.getElementById('incidentWarning').textContent = `Incident in ${distToIncident.toFixed(2)} mi`;
            } else {
                document.getElementById('incidentWarning').style.display = 'none';
            }
        }

        function zoomIn() { map.zoomIn(); }
        function zoomOut() { map.zoomOut(); }
        function toggleView() {
            const pitch = map.getPitch();
            map.easeTo({ pitch: pitch === 0 ? 60 : 0, duration: 1000 });
        }
        function goToCurrentLocation() {
            if (currentLocation) {
                map.flyTo({ center: currentLocation, zoom: 15 });
            } else {
                getCurrentLocation();
            }
        }

        function toggleSearch() {
            const panel = document.getElementById('searchPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
            if (panel.style.display === 'block') {
                document.getElementById('destinationInput').focus();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            document.getElementById('destinationInput').addEventListener('keypress', e => {
                if (e.key === 'Enter') searchDestination();
            });
        });

        setInterval(() => {
    if (navigationStarted) {
        updateNavigationInfo();
    }
}, 1000);
    </script>
</body>
</html>
